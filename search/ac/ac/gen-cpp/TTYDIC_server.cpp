// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "TTYDIC.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
// added by TTYDIC developper
#include "darts.h"
#include <stdexcept>
#include <iostream>

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using boost::shared_ptr;

using namespace Jingoo;

class TTYDICHandler : virtual public TTYDICIf {
 public:
  TTYDICHandler(std::string trie_file) {
    // Your initialization goes here
    if (da.open(trie_file.c_str()) != 0) {
      throw std::runtime_error("can't open a trie file.");
    }
  }

  void search(std::vector<std::string> & _return, const std::string& text) {
    // Your implementation goes here
    const char *text_char = text.c_str();
    const char *begin = text_char;
    const char *end   = text_char + strlen(text_char);

    Darts::DoubleArray::result_pair_type daresult[512];
    while (begin < end) {
      size_t size = da.commonPrefixSearch(begin, daresult, 512, (size_t)(end - begin));
      size_t seekto = 0;

      if (size) {
        // finding the longest match ?
        for (size_t i = 0; i < size; ++i) {
          if (seekto < daresult[i].length) {
            seekto = daresult[i].length;
          }
        }
	 
        if (seekto) {
          std::string word(begin, seekto);
          _return.push_back(word);
          begin += seekto;
        }
      }
       
      if (seekto == 0) {
        ++begin; 
      }
    }
  }

 private:
    Darts::DoubleArray da;
};

int main(int argc, char **argv)
{
  if (argc != 2) {
    std::cerr << "Usage: " << argv[0] << " trie_file" << std::endl;
    return -1;
  }
  int port = 9090;
  try {
    shared_ptr<TTYDICHandler> handler(new TTYDICHandler(argv[1]));
    shared_ptr<TProcessor> processor(new TTYDICProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
  } catch (std::runtime_error &e) {
    std::cout << "error: " << e.what() << std::endl;
  }
  return 0;
}

